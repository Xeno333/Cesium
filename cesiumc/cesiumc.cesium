import stdlib.cesium
c{
	#include <unistd.h>
}c


//req free
mut u8* fin = NULL
mut u8* foutmid = NULL
mut u8* gcc_args = NULL
mut u8* foutc = NULL

//other
mut u8* fout = NULL


func leave() : i32 {
	if (fin != NULL) {
		free(fin)
	}
	if (foutc != NULL) {
		free(foutc)
	}
	if (foutmid != NULL) {
		free(foutmid)
	}
	if (gcc_args != NULL) {
		free(gcc_args)
	}

	printf("\n")
	return 0
}


//checks if s1 starts with s2 and directly after s2 in s1, s1 ends with ' ' or '\t'
func startswith(u8* s1, u8* s2) : bool {
	mut u64 p = -1

	while (true) {
		p++

		//if p2 ends
		if (s2[p] == 0) {
			break
		}

		//compare
		if (s2[p] == s1[p]) {
			continue
		}

		//if s1 is ended
		if (s1[p] == 0) {
			return false
		}
		//if not equal
		return false
	}

	if ((s1[p] == '\t') || (s1[p] == ' ')) {
		return true
	}

	return false
}

func getlinelen(u8* str) : u64 {
    mut u64 r = 0
    while ((str[r] != '\n') && (str[r] != 0) && (str[r] != ';')) {
        r++
    }
    r++
    return r
}

func parse_line(u8* line)  : u8* {
	//strimp spaces

	//dopart
	if (startswith(line, "import")) {
		mut u64 p = 6
		while (true) {
			if ((line[p] == ' ') || (line[p] == '\t')) {
				p++
				continue
			}
			break
		}
		return line + p
	}
	if (startswith(line, "break")) {
		append(foutmid, "break\n", (getstrlen("break\n") - 1) : u64)
		append(foutmid, "ENDSTATEMENT\n", (getstrlen("ENDSTATEMENT\n") - 1) : u64)
		return NULL
	}

	return NULL//line2
}

func gimpf(u8* fn, mut u8* block) : u8* {
	if (startswith(fn, "/") || startswith(fn, ".") || startswith(fn, "~")) {
		return fn
	}

	mut u8 b1[2048]
	readlink("/proc/self/exe", b1, 2048-270)
	u8 *last_slash = strrchr(b1, '/');
	*last_slash = 0
	strcpy(block, b1)
	strcat(block, "/lib/")
	strcat(block, fn)
	return block
}

func parse(u8* f) {
	mut u64 e = getstrlen(f)
	mut u64 p = 0

	//loop lines
	while (p <= e) {
		u64 llen = getlinelen((f+p))
		mut u8* l = malloc(llen)

		mut u64 i = 0
		while (i != (llen - 1)) {
			l[i] = (f+p)[i]
			i++
		}
		l[i] = 0

		//Import
		if (parse_line(l) != NULL) {
			char path[2048];
			u8* fimp = fget(gimpf(parse_line(l), path))
			u64 fimps = getstrlen(fimp)
			mut u8* block = malloc(e + fimps + 1)

			//do import
			mut u64 p1 = 0
			mut u64 p2 = 0
			while (p2 != p) {
				block[p1++] = f[p2++]
			}
			p2 = 0
			while (p2 != fimps-1) {
				block[p1++] = fimp[p2++]
			}
			p2 = p + llen
			while (p2 != e+1) {
				block[p1++] = f[p2++]
			}

			printf("%s", block)

			//Next part
			
			free(fimp)

			free(f)
			f = block
			e = getstrlen(f)
		}
		
		free(l)
		p += llen
	}
	
	return
}



//main function
func main(i32 argc, u8** args) : i32 {
	//printf("Hello from cesiumc!\nRunning command: ")

	mut u64 i = 2
	mut u64 out_args_len = 1
	while (i != argc) {
		out_args_len += (getstrlen(args[i])) : u64
		i++
	}

	gcc_args = malloc(out_args_len)
	gcc_args[0] = 0
	strcat

	i = 2
	while (i != argc) {
		strcat(gcc_args, args[i])
		strcat(gcc_args, " ")
		i++
	}

	foutmid = malloc((getstrlen(args[1]) + getstrlen(".midpoint") - 1) : u64)
	strcpy(foutmid, args[1])
	strcat(foutmid, ".midpoint")

	foutc = malloc((getstrlen(args[1]) + getstrlen(".c") - 1) : u64)
	strcpy(foutc, args[1])
	strcat(foutc, ".c")


	fin = fget(args[1])

	//parse(fin)

	mut u8* cmd = malloc(getstrlen(gcc_args) + getstrlen(foutc) + getstrlen("gcc "))
	strcpy(cmd, "gcc ")
	strcat(cmd, foutc)
	strcat(cmd, " ")
	strcat(cmd, gcc_args)
	printf("\nCompile with: %s\n\n", cmd)
	//system(cmd)
	free(cmd)

	return leave()
}
